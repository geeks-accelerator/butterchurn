<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Butterchurn Intelligent Preset Selector Test</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .header p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        /* Main layout grid */
        .viz-container {
            display: grid;
            grid-template-areas:
                "mode-bar mode-bar"
                "canvas-area control-sidebar"
                "analysis-grid analysis-grid";
            grid-template-columns: 2fr 1fr;
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Mode control bar */
        .mode-controls {
            grid-area: mode-bar;
            background: #111;
            border: 1px solid #0f0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* Canvas area */
        .canvas-area {
            grid-area: canvas-area;
            background: #111;
            border: 1px solid #0f0;
            padding: 15px;
            text-align: center;
        }
        #canvas {
            border: 1px solid #0f0;
            max-width: 100%;
            height: auto;
            width: 720px;
            height: 405px;
        }
        .audio-bars {
            display: flex;
            justify-content: center;
            margin: 15px auto 0;
            height: 60px;
            width: 720px;
            max-width: 100%;
        }
        .bar {
            flex: 1;
            background: #0f0;
            margin: 0 1px;
            transition: height 0.1s;
            align-self: flex-end;
            min-width: 2px;
            max-width: 8px;
        }

        /* Control sidebar */
        .control-sidebar {
            grid-area: control-sidebar;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Analysis grid */
        .analysis-grid {
            grid-area: analysis-grid;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        /* Card styling */
        .info {
            background: #111;
            padding: 12px;
            border: 1px solid #0f0;
            border-radius: 4px;
        }
        .info h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #0f0;
        }

        /* Compact controls */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        .controls input[type="file"] {
            grid-column: 1 / -1;
        }

        /* Emergency controls grid */
        .emergency-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        /* Buttons */
        button, input[type="file"] {
            background: #0f0;
            color: #000;
            border: none;
            padding: 8px 12px;
            font-family: inherit;
            cursor: pointer;
            font-size: 0.85em;
        }
        button:hover {
            background: #0a0;
        }
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Preset info layout */
        .preset-info {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
        }
        .label {
            color: #999;
            flex-shrink: 0;
            margin-right: 10px;
        }
        .value {
            color: #0f0;
            text-align: right;
            word-break: break-word;
        }

        /* Scrollable content for tall sections */
        .scrollable {
            max-height: 300px;
            overflow-y: auto;
        }

        /* Status messages */
        .error {
            color: #f00;
            background: #300;
            padding: 8px;
            margin: 8px 0;
            border: 1px solid #f00;
            border-radius: 2px;
            font-size: 0.85em;
        }
        .success {
            color: #0f0;
            background: #030;
            padding: 8px;
            margin: 8px 0;
            border: 1px solid #0f0;
            border-radius: 2px;
            font-size: 0.85em;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .viz-container {
                grid-template-areas:
                    "mode-bar"
                    "canvas-area"
                    "control-sidebar"
                    "analysis-grid";
                grid-template-columns: 1fr;
            }
            #canvas {
                width: 600px;
                height: 338px;
            }
            .audio-bars {
                width: 600px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            .viz-container {
                gap: 10px;
            }
            #canvas {
                width: 480px;
                height: 270px;
            }
            .audio-bars {
                height: 40px;
                width: 480px;
            }
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            .controls {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 520px) {
            #canvas {
                width: 360px;
                height: 203px;
            }
            .audio-bars {
                width: 360px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéµ Butterchurn Intelligent Preset Selector</h1>
        <p>Phase 2: Equation-based fingerprinting with real-time intelligent selection</p>
    </div>

    <div class="viz-container">
        <!-- Mode control bar -->
        <div class="mode-controls">
            <div>
                <span class="label">Current Preset:</span>
                <span class="value" id="currentPreset">No audio loaded</span>
            </div>
            <div>
                <span class="label">Presets in Database:</span>
                <span class="value" id="presetCount">-</span>
            </div>
            <div>
                <button id="autoBtn" disabled>Auto Mode: ON</button>
                <button id="nextBtn" disabled>Next Preset</button>
            </div>
        </div>

        <!-- Canvas area -->
        <div class="canvas-area">
            <div class="info">
                <h3>üìÅ Audio File</h3>
                <input type="file" id="fileInput" accept="audio/*" />
                <div id="audioStatus"></div>
            </div>
            <canvas id="canvas" width="720" height="405"></canvas>
            <div class="audio-bars" id="audioBars"></div>
            <div class="controls">
                <button id="playBtn" disabled>Play/Pause</button>
                <button id="nextBtn" disabled>Next Preset (Manual)</button>
            </div>
        </div>

        <!-- Control sidebar -->
        <div class="control-sidebar">
            <!-- System Status -->
            <div class="info scrollable">
                <h3>üéõÔ∏è System Status</h3>
                <div class="preset-info">
                    <span class="label">Preset Hash:</span>
                    <span class="value" id="presetHash">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Authors:</span>
                    <span class="value" id="presetAuthors">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Energy Level:</span>
                    <span class="value" id="energyLevel">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Bass Reactivity:</span>
                    <span class="value" id="bassReactivity">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Musical Event:</span>
                    <span class="value" id="musicalEvent">Waiting...</span>
                </div>
                <div class="preset-info">
                    <span class="label">Next Transition:</span>
                    <span class="value" id="switchTimer">-</span>
                </div>
            </div>

            <!-- Emergency System -->
            <div class="info" style="border-color: #FF9500;">
                <h3>üõ°Ô∏è Emergency System</h3>
                <div class="preset-info">
                    <span class="label">Emergency Mode:</span>
                    <span class="value" id="emergencyMode">Inactive</span>
                </div>
                <div class="preset-info">
                    <span class="label">Emergency Presets:</span>
                    <span class="value" id="emergencyCount">3 available</span>
                </div>
                <div class="preset-info">
                    <span class="label">Failure Count:</span>
                    <span class="value" id="failureCount">0</span>
                </div>
                <div class="emergency-controls">
                    <button id="emergencyBtn">Test Emergency Mode</button>
                    <button id="testMinimalBtn" disabled>Minimal Emergency</button>
                    <button id="testReactiveBtn" disabled>Reactive Emergency</button>
                    <button id="testCrowdBtn" disabled>Crowd Pleaser Emergency</button>
                </div>
            </div>

            <!-- Blocklist Management -->
            <div class="info">
                <h3>üö´ Blocklist Management</h3>
                <div class="preset-info">
                    <span class="label">Blocked Presets:</span>
                    <span class="value" id="blockedCount">0</span>
                </div>
                <div class="preset-info">
                    <span class="label">Auto-Blocklist:</span>
                    <span class="value" id="autoBlocklist">Enabled</span>
                </div>
                <div class="preset-info">
                    <span class="label">Session Failures:</span>
                    <span class="value" id="sessionFailures">0</span>
                </div>
                <div class="emergency-controls">
                    <button id="showBlocklistBtn">Show Blocklist Manager</button>
                    <button id="clearBlocklistBtn">Clear All Blocklists</button>
                </div>
            </div>

            <!-- Quality Control -->
            <div class="info">
                <h3>‚ö° Quality Control</h3>
                <div class="preset-info">
                    <span class="label">Frame Rate:</span>
                    <span class="value" id="frameRate">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Render Time:</span>
                    <span class="value" id="renderTime">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Problematic Presets:</span>
                    <span class="value" id="problematicCount">0 detected</span>
                </div>
                <div class="preset-info">
                    <span class="label">Preset Health:</span>
                    <span class="value" id="presetHealth">‚úÖ Good</span>
                </div>
            </div>
        </div>

        <!-- Analysis grid at bottom -->
        <div class="analysis-grid">
            <!-- Audio Analysis Panel -->
            <div class="info">
                <h3>üìä Audio Analysis</h3>
                <div class="preset-info">
                    <span class="label">Bass Energy:</span>
                    <span class="value" id="bassEnergy">0.00</span>
                </div>
                <div class="preset-info">
                    <span class="label">Mid Energy:</span>
                    <span class="value" id="midEnergy">0.00</span>
                </div>
                <div class="preset-info">
                    <span class="label">Treble Energy:</span>
                    <span class="value" id="trebleEnergy">0.00</span>
                </div>
                <div class="preset-info">
                    <span class="label">Overall Energy:</span>
                    <span class="value" id="overallEnergy">0.00</span>
                </div>
                <div class="preset-info">
                    <span class="label">Beat Detection:</span>
                    <span class="value" id="beatDetect">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Beat Strength:</span>
                    <span class="value" id="beatDetection">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Spectral Centroid:</span>
                    <span class="value" id="spectralCentroid">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Zero Crossing Rate:</span>
                    <span class="value" id="zeroCrossing">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Dynamic Range:</span>
                    <span class="value" id="dynamicRange">-</span>
                </div>
            </div>

            <!-- Frame Analysis Panel -->
            <div class="info">
                <h3>üé¨ Frame Analysis</h3>
                <div class="preset-info">
                    <span class="label">Frame Status:</span>
                    <span class="value" id="frameStatus">Normal</span>
                </div>
                <div class="preset-info">
                    <span class="label">Black Frames:</span>
                    <span class="value" id="blackFrames">0</span>
                </div>
                <div class="preset-info">
                    <span class="label">Stuck Frames:</span>
                    <span class="value" id="stuckFrames">0</span>
                </div>
                <div class="preset-info">
                    <span class="label">Analysis Active:</span>
                    <span class="value" id="analysisActive">Yes</span>
                </div>
                <div class="preset-info">
                    <span class="label">Solid Color:</span>
                    <span class="value" id="solidColor">No</span>
                </div>
                <div class="preset-info">
                    <span class="label">Frame Hash:</span>
                    <span class="value" id="frameHash">N/A</span>
                </div>
            </div>

            <!-- Selection Logic Panel -->
            <div class="info">
                <h3>üéØ Selection Logic</h3>
                <div class="preset-info">
                    <span class="label">Target Energy:</span>
                    <span class="value" id="targetEnergy">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Score Calculation:</span>
                    <span class="value" id="scoreCalc">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Top Candidates:</span>
                    <span class="value" id="topCandidates">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Selection Reason:</span>
                    <span class="value" id="selectionReason">-</span>
                </div>
            </div>

            <!-- Preference Learning Panel -->
            <div class="info">
                <h3>üß† Learning Preferences</h3>
                <div class="preset-info">
                    <span class="label">Session Duration:</span>
                    <span class="value" id="sessionDuration">0m 0s</span>
                </div>
                <div class="preset-info">
                    <span class="label">Presets Shown:</span>
                    <span class="value" id="presetsShown">0</span>
                </div>
                <div class="preset-info">
                    <span class="label">Avg View Time:</span>
                    <span class="value" id="avgViewTime">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">Preferred Energy:</span>
                    <span class="value" id="preferredEnergy">Learning...</span>
                </div>
            </div>

            <!-- Device Capabilities Panel -->
            <div class="info">
                <h3>üì± Device Capabilities</h3>
                <div class="preset-info">
                    <span class="label">Device Tier:</span>
                    <span class="value" id="deviceTier">Detecting...</span>
                </div>
                <div class="preset-info">
                    <span class="label">Memory:</span>
                    <span class="value" id="deviceMemory">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">CPU Cores:</span>
                    <span class="value" id="deviceCores">-</span>
                </div>
                <div class="preset-info">
                    <span class="label">GPU:</span>
                    <span class="value" id="deviceGPU">-</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Load our local improved Butterchurn build (UMD format with Phase 1 improvements) -->
    <script src="../dist/butterchurn.min.js"></script>
    <!-- Load presets from CDN -->
    <!-- Load multiple preset packs for full collection -->
    <script src="../presets/full-collection/butterchurnPresets.min.js"></script>
    <script src="../presets/full-collection/butterchurnPresetsExtra.min.js"></script>
    <script src="../presets/full-collection/butterchurnPresetsExtra2.min.js"></script>
    <script src="../presets/full-collection/butterchurnPresetsMD1.min.js"></script>
    <script src="../presets/full-collection/butterchurnPresetsNonMinimal.min.js"></script>

    <script>
        // Wait for scripts to load
        window.addEventListener('load', function() {
            console.log('Page loaded, checking for butterchurn...');
            if (typeof butterchurn === 'undefined') {
                console.error('butterchurn is not defined after load!');
                console.log('window.butterchurn:', window.butterchurn);
                console.log('window.Butterchurn:', window.Butterchurn);
                // Check what's available on window
                console.log('Available on window:', Object.keys(window).filter(k => k.toLowerCase().includes('butter')));
            } else {
                console.log('butterchurn is available:', butterchurn);
            }
        });
    </script>

    <!-- IntelligentPresetSelector is now included in butterchurn bundle -->
    <!-- <script src="../src/intelligentPresetSelector.js"></script> -->

    <script>
        // Main application code
        let visualizer;
        let canvas;
        let audioContext;
        let analyser;
        let source;
        let audioElement;
        let isPlaying = false;
        let autoMode = true;
        let animationId;
        let selector;
        let fingerprintDb;

        // Performance tracking
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let renderTimes = [];
        let problematicPresetCount = 0;

        // Preference learning
        let sessionStartTime = Date.now();
        let presetsShownCount = 0;
        let presetViewTimes = [];
        let lastPresetSwitch = Date.now();
        let energyPreferences = [];

        // Audio bars will be created in init() after canvas is ready

        // IntelligentPresetSelector is now included in the butterchurn bundle
        // Access it from the butterchurn exports
        const IntelligentPresetSelector = (typeof butterchurn !== 'undefined' && butterchurn.IntelligentPresetSelector) ||
                                          (typeof butterchurn !== 'undefined' && butterchurn.default && butterchurn.default.IntelligentPresetSelector) ||
                                          window.IntelligentPresetSelector;
        // No need for inline implementation - using authoritative version

        function showError(message) {
            document.getElementById('audioStatus').innerHTML = `<div class="error">${message}</div>`;
        }

        function showSuccess(message) {
            document.getElementById('audioStatus').innerHTML = `<div class="success">${message}</div>`;
        }

        function updatePreferenceLearning() {
            // Update session duration
            const sessionTime = (Date.now() - sessionStartTime) / 1000;
            const minutes = Math.floor(sessionTime / 60);
            const seconds = Math.floor(sessionTime % 60);
            document.getElementById('sessionDuration').textContent = `${minutes}m ${seconds}s`;

            // Update presets shown
            document.getElementById('presetsShown').textContent = presetsShownCount.toString();

            // Update average view time
            if (presetViewTimes.length > 0) {
                const avgTime = presetViewTimes.reduce((a, b) => a + b, 0) / presetViewTimes.length;
                document.getElementById('avgViewTime').textContent = `${avgTime.toFixed(1)}s`;
            }

            // Determine preferred energy level
            if (energyPreferences.length >= 5) {
                const avgEnergy = energyPreferences.reduce((a, b) => a + b, 0) / energyPreferences.length;
                let preference;
                if (avgEnergy < 0.3) {
                    preference = 'üåä Calm (< 30%)';
                } else if (avgEnergy < 0.5) {
                    preference = 'üéµ Moderate (30-50%)';
                } else if (avgEnergy < 0.7) {
                    preference = 'üé∏ Energetic (50-70%)';
                } else {
                    preference = 'üî• High Energy (> 70%)';
                }
                document.getElementById('preferredEnergy').textContent = preference;
                console.log(`[Preferences] Energy learned: ${preference} (avg: ${avgEnergy.toFixed(2)}, samples: ${energyPreferences.length})`);
            } else {
                // Show progress toward learning
                document.getElementById('preferredEnergy').textContent =
                    `Learning... (${energyPreferences.length}/5 samples)`;
            }
        }

        function updatePresetInfo(presetName) {
            document.getElementById('currentPreset').textContent = presetName.substring(0, 50) +
                (presetName.length > 50 ? '...' : '');

            // Track preference learning
            const now = Date.now();
            if (lastPresetSwitch > 0) {
                const viewTime = (now - lastPresetSwitch) / 1000;
                presetViewTimes.push(viewTime);
                if (presetViewTimes.length > 20) presetViewTimes.shift();
            }
            lastPresetSwitch = now;
            presetsShownCount++;

            // Extract hash if we had the database
            if (fingerprintDb && fingerprintDb.nameIndex && fingerprintDb.nameIndex[presetName]) {
                const hash = fingerprintDb.nameIndex[presetName];
                document.getElementById('presetHash').textContent = hash;

                const presetData = fingerprintDb.presets[hash];
                if (presetData) {
                    document.getElementById('presetAuthors').textContent =
                        presetData.authors.join(', ');
                    document.getElementById('energyLevel').textContent =
                        `${(presetData.fingerprint.energy * 100).toFixed(0)}%`;
                    document.getElementById('bassReactivity').textContent =
                        `${(presetData.fingerprint.bass * 100).toFixed(0)}%`;

                    // Track energy preferences
                    energyPreferences.push(presetData.fingerprint.energy);
                    if (energyPreferences.length > 20) energyPreferences.shift();
                }
            } else {
                // Fallback: Track energy preferences from live audio analysis when no database
                const currentOverallEnergy = parseFloat(document.getElementById('overallEnergy').textContent) || 0;
                if (currentOverallEnergy > 0) {
                    energyPreferences.push(currentOverallEnergy);
                    if (energyPreferences.length > 20) energyPreferences.shift();
                }
            }

            // Update preference learning displays
            updatePreferenceLearning();
        }

        function detectDeviceCapabilities() {
            // Memory detection
            const memory = navigator.deviceMemory || 'Unknown';
            document.getElementById('deviceMemory').textContent =
                memory === 'Unknown' ? 'Unknown' : `${memory} GB`;

            // CPU cores detection
            const cores = navigator.hardwareConcurrency || 'Unknown';
            document.getElementById('deviceCores').textContent =
                cores === 'Unknown' ? 'Unknown' : cores.toString();

            // GPU detection
            detectGPU().then(gpu => {
                document.getElementById('deviceGPU').textContent = gpu;
            });

            // Device tier calculation (similar to IntelligentSelector logic)
            const isMobile = /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent);
            let tier;

            if (isMobile) {
                tier = 'üì± Mobile';
            } else if (memory >= 8 && cores >= 4) {
                tier = 'üñ•Ô∏è High-end';
            } else if (memory <= 4 && cores <= 2) {
                tier = 'üíª Low-end';
            } else {
                tier = 'üñ•Ô∏è Mid-range';
            }

            document.getElementById('deviceTier').textContent = tier;

            console.log(`[Device] Detected: ${tier}, Memory: ${memory}GB, Cores: ${cores}, Mobile: ${isMobile}`);
        }

        async function detectGPU() {
            try {
                // Try to get WebGL context for GPU info
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!gl) {
                    return 'WebGL not supported';
                }

                // Get GPU renderer info
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);

                    // Simplify common GPU names
                    if (renderer.includes('NVIDIA')) {
                        return 'üî• NVIDIA ' + renderer.split('NVIDIA')[1].trim();
                    } else if (renderer.includes('AMD') || renderer.includes('Radeon')) {
                        return 'üî¥ AMD ' + renderer.split(/AMD|Radeon/)[1].trim();
                    } else if (renderer.includes('Intel')) {
                        return 'üîµ Intel ' + renderer.split('Intel')[1].trim();
                    } else if (renderer.includes('Apple')) {
                        return 'üçé Apple GPU';
                    } else {
                        // Truncate long GPU names
                        return renderer.length > 30 ? renderer.substring(0, 30) + '...' : renderer;
                    }
                } else {
                    return 'GPU info restricted';
                }
            } catch (error) {
                console.warn('GPU detection failed:', error);
                return 'Detection failed';
            }
        }

        async function init() {
            canvas = document.getElementById('canvas');

            // Create audio bars for visualization - more bars that scale with canvas width
            const barsContainer = document.getElementById('audioBars');
            const numBars = Math.floor(canvas.width / 6); // One bar every 6 pixels for dense visualization
            console.log(`Creating ${numBars} audio bars for canvas width ${canvas.width}px`);

            // Clear any existing bars first
            barsContainer.innerHTML = '';

            for (let i = 0; i < numBars; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                barsContainer.appendChild(bar);
            }

            try {
                // Detect and display device capabilities
                detectDeviceCapabilities();

                // Create audio context first - butterchurn needs this
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Created audio context');
                }

                // Initialize Butterchurn using our UMD build
                // Check what form butterchurn is available in
                let Butterchurn;
                if (typeof butterchurn !== 'undefined') {
                    Butterchurn = butterchurn.default || butterchurn;
                } else if (typeof window.butterchurn !== 'undefined') {
                    Butterchurn = window.butterchurn.default || window.butterchurn;
                } else {
                    throw new Error('Butterchurn library not loaded! Check if ../dist/butterchurn.min.js exists and loads correctly.');
                }

                console.log('Using Butterchurn:', Butterchurn);

                if (!Butterchurn.createVisualizer) {
                    throw new Error('Butterchurn.createVisualizer not found. Build may be corrupted.');
                }

                // Create visualizer with audio context and canvas
                visualizer = Butterchurn.createVisualizer(audioContext, canvas, {
                    width: canvas.width,
                    height: canvas.height
                });

                // Load fingerprint database - optional, will fail with CORS if opened as file://
                try {
                    // Try to load from same directory first (test directory)
                    const response = await fetch('./fingerprints.json');
                    if (response.ok) {
                        fingerprintDb = await response.json();
                        document.getElementById('presetCount').textContent =
                            `${Object.keys(fingerprintDb.presets).length} unique`;
                        console.log('‚úÖ Fingerprint database loaded');
                    } else {
                        console.warn('Fingerprint database not found, using presets without deduplication');
                        document.getElementById('presetCount').textContent = 'No database';
                    }
                } catch (err) {
                    // CORS error when opened as file:// - this is expected
                    if (err.message.includes('CORS') || err.message.includes('Failed to fetch')) {
                        console.info('Note: Fingerprint database unavailable due to CORS (normal when opening file directly)');
                        console.info('To use fingerprints, either:');
                        console.info('1. Serve via local server: python3 -m http.server 8000');
                        console.info('2. Or open from a web server');
                    } else {
                        console.warn('Could not load fingerprint database:', err);
                    }
                    document.getElementById('presetCount').textContent = 'CORS blocked (normal)';
                    // Continue without database - the app still works
                    fingerprintDb = null;
                }

                // Initialize selector
                if (!IntelligentPresetSelector) {
                    console.error('IntelligentPresetSelector not found! Check if butterchurn bundle is loaded correctly.');
                    showError('IntelligentPresetSelector not found in bundle');
                    return;
                }
                selector = new IntelligentPresetSelector(visualizer, fingerprintDb || {});

                // Combine all preset packs into one collection
                const allPresets = {};

                // Add all available preset packs
                if (typeof butterchurnPresets !== 'undefined') {
                    Object.assign(allPresets, butterchurnPresets.getPresets());
                    console.log('‚úì Loaded butterchurnPresets');
                }
                if (typeof butterchurnPresetsExtra !== 'undefined') {
                    Object.assign(allPresets, butterchurnPresetsExtra.getPresets());
                    console.log('‚úì Loaded butterchurnPresetsExtra');
                }
                if (typeof butterchurnPresetsExtra2 !== 'undefined') {
                    Object.assign(allPresets, butterchurnPresetsExtra2.getPresets());
                    console.log('‚úì Loaded butterchurnPresetsExtra2');
                }
                if (typeof butterchurnPresetsMD1 !== 'undefined') {
                    Object.assign(allPresets, butterchurnPresetsMD1.getPresets());
                    console.log('‚úì Loaded butterchurnPresetsMD1');
                }
                if (typeof butterchurnPresetsNonMinimal !== 'undefined') {
                    Object.assign(allPresets, butterchurnPresetsNonMinimal.getPresets());
                    console.log('‚úì Loaded butterchurnPresetsNonMinimal');
                }

                console.log(`üì¶ Combined preset collection: ${Object.keys(allPresets).length} total presets`);
                selector.setPresetPack(allPresets);

                const presetNames = Object.keys(allPresets);
                if (presetNames.length > 0) {
                    // Find first valid preset (not blank)
                    let firstValidPreset = null;
                    for (const name of presetNames) {
                        const preset = allPresets[name];
                        if (preset.baseVals && preset.frame_eqs_str) {
                            firstValidPreset = name;
                            break;
                        }
                    }

                    if (!firstValidPreset) {
                        console.error('[INIT] No valid presets found in pack!');
                        firstValidPreset = presetNames[0]; // Fallback to first anyway
                    }

                    console.log('[INIT] Loading first preset:', firstValidPreset);
                    console.log('[INIT] First preset object structure:', {
                        hasBaseVals: !!allPresets[firstValidPreset].baseVals,
                        hasFrameEqs: !!allPresets[firstValidPreset].frame_eqs_str,
                        presetKeys: Object.keys(allPresets[firstValidPreset]).slice(0, 10)
                    });
                    console.log('[INIT] All 395 presets are loaded and available for selection');
                    visualizer.loadPreset(allPresets[firstValidPreset], 0); // No blending for first preset
                    updatePresetInfo(firstValidPreset);

                    // Update selector state for first preset
                    selector.currentPreset = firstValidPreset;
                    selector.lastSwitch = performance.now();
                    console.log('[INIT] First preset loaded successfully');
                } else {
                    console.error('[INIT] No presets available!');
                }

                showSuccess('‚úÖ Butterchurn initialized. Please select an audio file.');

                // Enable emergency preset test buttons since visualizer is ready
                document.getElementById('testMinimalBtn').disabled = false;
                document.getElementById('testReactiveBtn').disabled = false;
                document.getElementById('testCrowdBtn').disabled = false;

            } catch (error) {
                console.error('Failed to initialize:', error);
                showError('Failed to initialize: ' + error.message);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);

            // Create or update audio element
            if (audioElement) {
                audioElement.pause();
                audioElement.src = '';
            }

            audioElement = new Audio(url);
            audioElement.crossOrigin = 'anonymous';
            audioElement.controls = false;
            audioElement.volume = 1.0;

            // Setup Web Audio API
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (source) {
                source.disconnect();
            }

            source = audioContext.createMediaElementSource(audioElement);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            // Connect source to analyser first
            source.connect(analyser);

            // Connect analyser to destination for audio playback
            analyser.connect(audioContext.destination);

            // Also connect source directly to visualizer (it needs its own connection)
            if (visualizer && visualizer.connectAudio) {
                // Butterchurn needs a direct connection to the source
                source.connect(visualizer.audioNode || analyser);
                console.log('Connected visualizer to audio');
            }

            showSuccess(`‚úÖ Loaded: ${file.name}`);

            // Enable controls
            document.getElementById('playBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;

            // Enable emergency preset test buttons
            document.getElementById('testMinimalBtn').disabled = false;
            document.getElementById('testReactiveBtn').disabled = false;
            document.getElementById('testCrowdBtn').disabled = false;

            // Start animation loop
            if (!animationId) {
                animate();
            }
        }

        // Calculate advanced audio features
        function calculateAdvancedFeatures(dataArray, timeByteArray) {
            const features = {};

            // Beat detection - look for sudden amplitude changes
            let maxAmp = 0;
            let beatThreshold = 0;
            for (let i = 0; i < dataArray.length; i++) {
                if (dataArray[i] > maxAmp) maxAmp = dataArray[i];
                beatThreshold += dataArray[i];
            }
            beatThreshold = beatThreshold / dataArray.length * 1.5;
            features.beatDetected = maxAmp > beatThreshold;
            features.beatStrength = Math.min(1.0, maxAmp / 255);

            // Spectral centroid - brightness indicator
            let weightedSum = 0;
            let magnitudeSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                weightedSum += i * dataArray[i];
                magnitudeSum += dataArray[i];
            }
            features.spectralCentroid = magnitudeSum > 0 ?
                (weightedSum / magnitudeSum) / dataArray.length : 0;

            // Zero crossing rate - percussive content detector
            let zeroCrossings = 0;
            for (let i = 1; i < timeByteArray.length; i++) {
                const prev = timeByteArray[i - 1] - 128;
                const curr = timeByteArray[i] - 128;
                if ((prev < 0 && curr >= 0) || (prev >= 0 && curr < 0)) {
                    zeroCrossings++;
                }
            }
            features.zeroCrossingRate = zeroCrossings / timeByteArray.length;

            // Dynamic range
            let min = 255, max = 0;
            for (let i = 0; i < dataArray.length; i++) {
                if (dataArray[i] < min) min = dataArray[i];
                if (dataArray[i] > max) max = dataArray[i];
            }
            features.dynamicRange = (max - min) / 255;

            return features;
        }

        // Detect musical events based on audio features
        function detectMusicalEvent(features) {
            const event = {
                type: 'Steady',
                intensity: 0,
                upcoming: null
            };

            // High energy detection
            if (features.bass > 0.8 && features.vol > 0.7) {
                event.type = 'üî• DROP!';
                event.intensity = 1.0;
            } else if (features.bass > 0.6 && features.trend > 0.5) {
                event.type = 'üìà Building...';
                event.intensity = 0.7;
                event.upcoming = 'Drop expected';
            } else if (features.vol < 0.2) {
                event.type = 'üåä Ambient';
                event.intensity = 0.2;
            } else if (features.bass < 0.3 && features.trend < -0.3) {
                event.type = 'üìâ Breakdown';
                event.intensity = 0.3;
                event.upcoming = 'Buildup expected';
            } else if (features.mid > 0.6 && features.treb > 0.5) {
                event.type = 'üéµ Melodic';
                event.intensity = 0.5;
            } else if (features.bass > 0.5 && features.vol > 0.4) {
                event.type = 'üé∏ Groove';
                event.intensity = 0.6;
            } else if (Math.abs(features.trend) < 0.1) {
                event.type = '‚û°Ô∏è Steady';
                event.intensity = 0.4;
            }

            // Detect upcoming transitions based on patterns
            if (features.trend > 0.6 && features.vol > 0.5 && !event.upcoming) {
                event.upcoming = 'Peak approaching';
            } else if (features.trend < -0.5 && features.vol < 0.4 && !event.upcoming) {
                event.upcoming = 'Quiet section';
            }

            return event;
        }

        function animate() {
            if (!analyser) {
                animationId = requestAnimationFrame(animate);
                return;
            }

            // Get frequency data
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Get time domain data for Butterchurn (this is what makes it react to music!)
            const timeBufferLength = analyser.fftSize;
            const timeByteArray = new Uint8Array(timeBufferLength);
            analyser.getByteTimeDomainData(timeByteArray);

            // Calculate audio levels
            const bass = dataArray.slice(0, Math.floor(bufferLength * 0.1))
                .reduce((a, b) => a + b, 0) / (bufferLength * 0.1 * 255);
            const mid = dataArray.slice(Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5))
                .reduce((a, b) => a + b, 0) / (bufferLength * 0.4 * 255);
            const treb = dataArray.slice(Math.floor(bufferLength * 0.5))
                .reduce((a, b) => a + b, 0) / (bufferLength * 0.5 * 255);

            const audioLevels = {
                bass: bass,
                mid: mid,
                treb: treb,
                vol: (bass + mid + treb) / 3,
                // CRITICAL: Add time domain data for Butterchurn to actually react to music!
                timeByteArray: timeByteArray,
                timeByteArrayL: timeByteArray, // For stereo, we'd split this
                timeByteArrayR: timeByteArray
            };

            // Update bars visualization - distribute frequency data across all bars
            const bars = document.querySelectorAll('.bar');
            if (bars.length > 0) {
                const barStep = bufferLength / bars.length;

                for (let i = 0; i < bars.length; i++) {
                    // Average the frequency data for this bar's range
                    const startIndex = Math.floor(i * barStep);
                    const endIndex = Math.floor((i + 1) * barStep);
                    let sum = 0;
                    let count = 0;

                    for (let j = startIndex; j < endIndex && j < bufferLength; j++) {
                        sum += dataArray[j];
                        count++;
                    }

                    const avgValue = count > 0 ? sum / count : 0;
                    const normalizedValue = avgValue / 255;

                    // Scale height to fit container (60px for desktop, 40px for mobile)
                    const maxHeight = window.innerWidth <= 768 ? 40 : 60;
                    bars[i].style.height = `${normalizedValue * maxHeight}px`;
                }
            }

            // Check if audio has ended
            if (audioElement && audioElement.ended && isPlaying) {
                console.log('[Audio] Playback ended, stopping visualization updates');
                isPlaying = false;

                // Update UI to show stopped state
                showSuccess('üéµ Playback complete');
                document.getElementById('bassEnergy').textContent = '0.00';
                document.getElementById('midEnergy').textContent = '0.00';
                document.getElementById('trebleEnergy').textContent = '0.00';
                document.getElementById('overallEnergy').textContent = '0.00';
                document.getElementById('switchTimer').textContent = 'Stopped';
                document.getElementById('musicalEvent').textContent = 'Stopped';
            }

            // CRITICAL FIX: Only process audio and render when audio is actually playing
            if (isPlaying && audioElement && !audioElement.paused && !audioElement.ended) {
                // Update selector with real audio data (only if auto mode is on)
                if (selector && autoMode) {
                    const result = selector.update(audioLevels);

                    if (result) {
                        document.getElementById('bassEnergy').textContent = bass.toFixed(2);
                        document.getElementById('midEnergy').textContent = mid.toFixed(2);
                        document.getElementById('trebleEnergy').textContent = treb.toFixed(2);
                        document.getElementById('overallEnergy').textContent =
                            result.features.energy.toFixed(2);

                        // Track energy preferences from live audio (works without fingerprint DB)
                        energyPreferences.push(result.features.energy);
                        if (energyPreferences.length > 20) energyPreferences.shift();
                        document.getElementById('beatDetect').textContent =
                            result.features.trend;

                        // Calculate and display advanced audio features
                        const advancedFeatures = calculateAdvancedFeatures(dataArray, timeByteArray);

                        // Update advanced feature displays
                        document.getElementById('beatDetection').textContent =
                            advancedFeatures.beatDetected ?
                            `ü•Å ${(advancedFeatures.beatStrength * 100).toFixed(0)}%` : '---';
                        document.getElementById('spectralCentroid').textContent =
                            `${(advancedFeatures.spectralCentroid * 100).toFixed(1)}% bright`;
                        document.getElementById('zeroCrossing').textContent =
                            `${(advancedFeatures.zeroCrossingRate * 100).toFixed(1)}% percussive`;
                        document.getElementById('dynamicRange').textContent =
                            `${(advancedFeatures.dynamicRange * 100).toFixed(0)}% range`;

                        // Update musical event detection display
                        const musicalEvent = detectMusicalEvent(result.features);
                        document.getElementById('musicalEvent').textContent = musicalEvent.type;

                        // Show next transition timing based on musical context
                        if (result.nextSwitch) {
                            const timeUntilSwitch = (result.nextSwitch / 1000).toFixed(1);
                            const transitionReason = musicalEvent.upcoming ?
                                `${musicalEvent.upcoming} in ${timeUntilSwitch}s` :
                                `${timeUntilSwitch}s (min interval)`;
                            document.getElementById('switchTimer').textContent = transitionReason;
                        }

                        // Update selection logic transparency
                        if (result.selectionLogic) {
                            const logic = result.selectionLogic;
                            document.getElementById('targetEnergy').textContent =
                                `${(logic.targetEnergy * 100).toFixed(0)}%`;
                            document.getElementById('scoreCalc').textContent =
                                logic.topScores.length > 0 ? logic.topScores[0] : '-';
                            document.getElementById('topCandidates').textContent =
                                logic.candidates.length > 0 ?
                                logic.candidates.slice(0, 3).join(', ') : 'None';
                            document.getElementById('selectionReason').textContent =
                                logic.reason || 'Waiting...';
                        }
                    }
                }

                // Render visualization with real audio data
                if (visualizer) {
                    // Track render performance
                    const renderStart = performance.now();
                    visualizer.render({ audioLevels: audioLevels });
                    const renderEnd = performance.now();
                    const renderTime = renderEnd - renderStart;

                    // Update performance metrics
                    renderTimes.push(renderTime);
                    if (renderTimes.length > 60) renderTimes.shift();

                    // Perform frame analysis
                    if (selector && selector.frameAnalyzer && canvas) {
                        try {
                            const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
                            if (gl) {
                                // Read pixels from WebGL context
                                const width = canvas.width;
                                const height = canvas.height;
                                const pixels = new Uint8Array(width * height * 4);
                                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                                // Analyze the frame
                                const analysis = selector.frameAnalyzer.analyzeFrame(pixels, width, height);

                                // Update frame analysis UI
                                if (analysis) {
                                    document.getElementById('frameStatus').textContent =
                                        analysis.isProblematic ? '‚ö†Ô∏è Problematic' : '‚úÖ Normal';
                                    document.getElementById('blackFrames').textContent =
                                        analysis.isBlack ? 'Detected!' : '0';
                                    document.getElementById('stuckFrames').textContent =
                                        analysis.isStuck ? 'Detected!' : '0';
                                    document.getElementById('solidColor').textContent =
                                        analysis.isSolidColor ? 'Yes' : 'No';
                                    document.getElementById('frameHash').textContent =
                                        analysis.hash ? analysis.hash.toString(16).substring(0, 8) : 'N/A';

                                    // Update with actual metrics
                                    if (analysis.metrics) {
                                        document.getElementById('blackFrames').textContent =
                                            analysis.metrics.blackPixelRatio > 0.9 ?
                                            `${(analysis.metrics.blackPixelRatio * 100).toFixed(0)}%` : '0';
                                        document.getElementById('solidColor').textContent =
                                            analysis.metrics.colorVariance < 10 ? 'Yes' : 'No';
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Frame analysis error:', e);
                        }
                    }

                    frameCount++;
                    const now = performance.now();
                    if (now - lastFpsUpdate > 1000) {
                        const fps = frameCount;
                        frameCount = 0;
                        lastFpsUpdate = now;

                        // Update quality control displays
                        document.getElementById('frameRate').textContent =
                            fps < 30 ? `‚ö†Ô∏è ${fps} FPS` :
                            fps < 50 ? `üü° ${fps} FPS` :
                            `‚úÖ ${fps} FPS`;

                        const avgRenderTime = renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length;
                        document.getElementById('renderTime').textContent =
                            avgRenderTime > 16.7 ? `‚ö†Ô∏è ${avgRenderTime.toFixed(1)}ms` :
                            avgRenderTime > 10 ? `üü° ${avgRenderTime.toFixed(1)}ms` :
                            `‚úÖ ${avgRenderTime.toFixed(1)}ms`;

                        // Check preset health
                        if (selector && selector.problematicPresets) {
                            problematicPresetCount = selector.problematicPresets.size;
                            document.getElementById('problematicCount').textContent =
                                `${problematicPresetCount} detected`;
                        }

                        // Overall health indicator
                        const health = fps >= 50 && avgRenderTime <= 16.7 && problematicPresetCount < 5;
                        document.getElementById('presetHealth').textContent =
                            health ? '‚úÖ Good' :
                            fps < 30 || avgRenderTime > 20 ? '‚ùå Poor' :
                            'üü° Fair';

                        // Also update session duration periodically
                        updatePreferenceLearning();
                    }
                }
            } else {
                // Audio is paused/stopped - render static visualization without audio data
                if (visualizer) {
                    // Pass silent audio data so presets don't react randomly
                    const silentAudioLevels = {
                        bass: 0,
                        mid: 0,
                        treb: 0,
                        vol: 0,
                        timeByteArray: new Uint8Array(timeBufferLength).fill(128), // Flat line
                        timeByteArrayL: new Uint8Array(timeBufferLength).fill(128),
                        timeByteArrayR: new Uint8Array(timeBufferLength).fill(128)
                    };
                    visualizer.render({ audioLevels: silentAudioLevels });
                }

                // Update UI to show paused state
                if (!isPlaying && audioElement) {
                    document.getElementById('bassEnergy').textContent = '0.00';
                    document.getElementById('midEnergy').textContent = '0.00';
                    document.getElementById('trebleEnergy').textContent = '0.00';
                    document.getElementById('overallEnergy').textContent = '0.00';
                    document.getElementById('switchTimer').textContent = audioElement.paused ? 'Paused' : 'Stopped';
                    document.getElementById('musicalEvent').textContent = audioElement.paused ? 'Paused' : 'No Audio';
                }
            }

            animationId = requestAnimationFrame(animate);
        }

        // Event handlers
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        // Emergency preset button handlers
        document.getElementById('emergencyBtn').addEventListener('click', () => {
            if (selector) {
                // Use the selector's enterEmergencyMode method to properly set emergency mode
                selector.enterEmergencyMode({
                    reason: 'Manual test',
                    audioLevel: 0.5
                });

                // Update UI to reflect emergency mode
                document.getElementById('emergencyMode').textContent = 'Active';
                document.getElementById('emergencyMode').style.color = '#FF9500';

                // Show which preset was selected
                const currentPreset = selector.currentPreset || 'Unknown';
                updatePresetInfo('Emergency: ' + currentPreset);
                showSuccess('Emergency mode activated');
            }
        });

        document.getElementById('testMinimalBtn').addEventListener('click', () => {
            console.log('Test Minimal button clicked');
            console.log('selector exists:', !!selector);
            console.log('selector.emergencyManager:', selector?.emergencyManager);

            if (selector && selector.emergencyManager) {
                const preset = selector.emergencyManager.emergencyPresets.minimal;
                console.log('Minimal preset:', preset);

                if (preset && visualizer) {
                    // Set emergency mode flag to prevent auto-switching
                    selector.isEmergencyMode = true;
                    selector.emergencyStartTime = performance.now();

                    visualizer.loadPreset(preset, 0.5);
                    selector.currentHash = preset.id;
                    selector.currentPreset = preset.name;
                    selector.lastSwitch = performance.now();

                    updatePresetInfo('Emergency: Minimal');
                    document.getElementById('emergencyMode').textContent = 'Active';
                    document.getElementById('emergencyMode').style.color = '#FF9500';
                    showSuccess('Minimal emergency preset activated');
                } else {
                    showError('Preset or visualizer not available');
                }
            } else {
                showError('Emergency manager not available');
            }
        });

        document.getElementById('testReactiveBtn').addEventListener('click', () => {
            console.log('Test Reactive button clicked');
            if (selector && selector.emergencyManager) {
                const preset = selector.emergencyManager.emergencyPresets.basic_reactive;
                console.log('Reactive preset:', preset);

                if (preset && visualizer) {
                    // Set emergency mode flag to prevent auto-switching
                    selector.isEmergencyMode = true;
                    selector.emergencyStartTime = performance.now();

                    visualizer.loadPreset(preset, 0.5);
                    selector.currentHash = preset.id;
                    selector.currentPreset = preset.name;
                    selector.lastSwitch = performance.now();

                    updatePresetInfo('Emergency: Basic Reactive');
                    document.getElementById('emergencyMode').textContent = 'Active';
                    document.getElementById('emergencyMode').style.color = '#FF9500';
                    showSuccess('Basic Reactive emergency preset activated');
                } else {
                    showError('Preset or visualizer not available');
                }
            } else {
                showError('Emergency manager not available');
            }
        });

        document.getElementById('testCrowdBtn').addEventListener('click', () => {
            console.log('Test Crowd Pleaser button clicked');
            if (selector && selector.emergencyManager) {
                const preset = selector.emergencyManager.emergencyPresets.crowd_pleaser;
                console.log('Crowd Pleaser preset:', preset);

                if (preset && visualizer) {
                    // Set emergency mode flag to prevent auto-switching
                    selector.isEmergencyMode = true;
                    selector.emergencyStartTime = performance.now();

                    visualizer.loadPreset(preset, 0.5);
                    selector.currentHash = preset.id;
                    selector.currentPreset = preset.name;
                    selector.lastSwitch = performance.now();

                    updatePresetInfo('Emergency: Crowd Pleaser');
                    document.getElementById('emergencyMode').textContent = 'Active';
                    document.getElementById('emergencyMode').style.color = '#FF9500';
                    showSuccess('Crowd Pleaser emergency preset activated');
                } else {
                    showError('Preset or visualizer not available');
                }
            } else {
                showError('Emergency manager not available');
            }
        });

        // Blocklist management buttons
        document.getElementById('showBlocklistBtn').addEventListener('click', () => {
            if (selector && selector.blocklistManager) {
                // Initialize UI if not already done
                if (!selector.blocklistManager.uiContainer) {
                    selector.blocklistManager.initializeUI();
                }
                selector.blocklistManager.show();
            }
        });

        document.getElementById('clearBlocklistBtn').addEventListener('click', () => {
            if (confirm('Clear all blocklist data? This cannot be undone.')) {
                let cleared = 0;
                const keysToRemove = [];

                for (const key in localStorage) {
                    if (key.includes('preset-blocklist') || key.includes('preset-failures')) {
                        keysToRemove.push(key);
                        cleared++;
                    }
                }

                keysToRemove.forEach(key => localStorage.removeItem(key));

                updateBlocklistStats();
                showSuccess(`Cleared ${cleared} blocklist entries. Reload page to take effect.`);
            }
        });

        document.getElementById('playBtn').addEventListener('click', async () => {
            if (!audioElement) return;

            // Resume audio context if it's suspended (browser security)
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
                console.log('Resumed audio context');
            }

            if (isPlaying) {
                audioElement.pause();
                document.getElementById('playBtn').textContent = 'Play';
                isPlaying = false;
            } else {
                // Play audio with promise handling
                try {
                    await audioElement.play();
                    document.getElementById('playBtn').textContent = 'Pause';
                    isPlaying = true;
                    console.log('Audio playing, volume:', audioElement.volume, 'muted:', audioElement.muted);
                } catch (err) {
                    console.error('Error playing audio:', err);
                    showError('Failed to play audio: ' + err.message);
                }
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (selector) {
                selector.selectRandomPreset();
                updatePresetInfo(selector.currentPreset || 'Unknown');
            }
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            autoMode = !autoMode;
            document.getElementById('autoBtn').textContent = `Auto Mode: ${autoMode ? 'ON' : 'OFF'}`;

            // Update UI to show auto mode status
            if (!autoMode) {
                document.getElementById('switchTimer').textContent = 'Auto switching disabled';
                document.getElementById('selectionReason').textContent = 'Manual control';
                showSuccess('Auto mode disabled - use Next button to switch presets');
            } else {
                showSuccess('Auto mode enabled - presets will switch automatically');
            }
        });

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>